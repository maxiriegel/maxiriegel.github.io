<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>ðŸ¤– Homepage | Maxi Riegel</title>
  <!-- Retro/8-bit readable font -->
  <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
  <style>
    :root{
      --fg:#fff;
      --accent:#00ffff;
      --bg:#000;
      --ui-font:'VT323', monospace;
      --ui-size:clamp(18px,3.6vw,26px);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;overflow:hidden;background:#000;
      font-family:'Inter',system-ui,-apple-system,Segoe UI,Roboto,sans-serif;color:var(--fg);
      touch-action: none; /* Canvas-first Gestensteuerung auf Touch */
    }
    canvas{display:block}

    @supports (height: 100svh){
      html,body{height:100svh}
    }

    /* HUD: Kill Counter (oben mittig) */
    #kills{
      position:absolute;top:10px;left:50%;transform:translateX(-50%);
      font-family:var(--ui-font);font-size:var(--ui-size);line-height:1;
      color:#ffffff;opacity:.9;letter-spacing:.02em;
      text-shadow:0 0 8px rgba(0,255,255,.45), 0 0 2px rgba(0,0,0,.8);
      z-index:110;pointer-events:none;
    }

    /* Link-Leiste (unten) */
    #links{
      position:absolute;bottom:10px;width:100%;text-align:center;z-index:100;pointer-events:auto;
      padding-bottom:max(10px, env(safe-area-inset-bottom));
      padding-left:max(0px, env(safe-area-inset-left));
      padding-right:max(0px, env(safe-area-inset-right));
      font-family:var(--ui-font);
    }
    #links a{
      color:#fff;text-decoration:none;margin:0 15px;
      font-size:var(--ui-size);line-height:1;
      letter-spacing:.02em;
      text-shadow:0 0 6px rgba(0,255,255,.35), 0 0 2px rgba(0,0,0,.8);
      transition:transform .15s ease, color .15s ease, text-shadow .15s ease;
    }
    #links a:hover{color:#0ff; transform:translateY(-1px); text-shadow:0 0 10px rgba(0,255,255,.6) }
  </style>

  <!-- ES Module shims for wide browser support -->
  <script async src="https://ga.jspm.io/npm:es-module-shims@1.6.3/dist/es-module-shims.js"></script>
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
  </script>
</head>
<body>
  <div id="kills">0</div>

  <div id="links">
    <a href="https://www.linkedin.com/in/maximilianluisriegel/" target="_blank" rel="noopener">LinkedIn</a>
    <a href="https://github.com/maxiriegel"                     target="_blank" rel="noopener">GitHub</a>
    <a href="mailto:maximilianluis.riegel@gmail.com">E-Mail</a>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { mergeGeometries } from 'three/examples/jsm/utils/BufferGeometryUtils.js';

    /* ======= Konstanten ======= */
    const CHUNK_SIZE   = 200;
    const ACTIVE_RADIUS= 2;
    const isMobile     = /Mobi|Android/i.test(navigator.userAgent);

    // Spieler & NPCs
    const RUN_SPEED = 12;
    const NPC_COUNT= isMobile? 40: 60;
    const NPC_SPEED= 2.0;

    // Laser & FX
    const LASER_SPEED    = 70;
    const LASER_TILT_DEG = -1.2;
    const LASER_CORE_R   = 0.18;
    const LASER_GLOW_R   = 0.36;
    const LASER_LEN_HALF = 18;
    const LASER_CORE_COL = 0xff7a33;
    const LASER_GLOW_COL = 0xff2200;
    const MAX_BEAMS      = 24;

    // Render-QualitÃ¤t
    const MAX_RATIO = innerWidth>2000?1.5:2;

    /* ======= Globals ======= */
    let scene, camera, renderer, player;
    let camOffset = new THREE.Vector3(0,3.2,7.2), lookY = 2.2;
    const clock = new THREE.Clock();

    // State
    const beams=[];
    const beamPool=[];
    const npcs=[];
    const explosions=[];

    // HUD
    let kills = 0;
    const killsEl = document.getElementById('kills');

    // World streaming
    const gridChunks = new Map();
    const cityChunks = new Map();
    const active = new Set();
    const key = (x,z)=>`${x},${z}`;

    // Input
    let mouseX = innerWidth/2;
    const useSwipe = (('ontouchstart' in window) || navigator.maxTouchPoints > 0 || matchMedia('(pointer: coarse)').matches);
    let rotTarget = 0;
    const ROT_CLAMP = Math.PI * 3.2;
    const TOUCH_SENS = 0.007;

    // Touch-Drag State
    let dragging = false;
    let startX = 0, startY = 0, lastX = 0, startTime = 0, moved = false;

    // Temp Vektoren
    const TMP_V1 = new THREE.Vector3();
    const TMP_V2 = new THREE.Vector3();

    // Adaptive Performance
    let msAvg = 16, resCooldown = 0;
    const NPC_MAX = NPC_COUNT;
    let npcBudget = NPC_MAX;

    // Laser: Geometrien/Materialien
    const LASER_CORE_GEOM = new THREE.CylinderGeometry(LASER_CORE_R, LASER_CORE_R, 1, 20, 1, true);
    const LASER_GLOW_GEOM = new THREE.CylinderGeometry(LASER_GLOW_R, LASER_GLOW_R, 1, 12, 1, true);
    const LASER_CORE_MAT  = new THREE.MeshBasicMaterial({ color:LASER_CORE_COL, transparent:true, opacity:1.0, blending:THREE.AdditiveBlending, depthWrite:false, toneMapped:false });
    const LASER_GLOW_MAT  = new THREE.MeshBasicMaterial({ color:LASER_GLOW_COL, transparent:true, opacity:0.32, blending:THREE.AdditiveBlending, depthWrite:false, side:THREE.DoubleSide, toneMapped:false });

    const EXPLO_MAT  = new THREE.SpriteMaterial({color:0xff6600, transparent:true, opacity:1, blending:THREE.AdditiveBlending, toneMapped:false});

    // Neon-Palette (>=6 Farben â†’ 10 Farben)
    const NEON = [
      0x00ffff, 0xff00ff, 0x55ff88, 0xffff66, 0xff7a33,
      0xff3366, 0x66ccff, 0xff66cc, 0xaaff00, 0xffdd55
    ];

    /* ======= Materialien/Geometrien fÃ¼r Bot ======= */
    const MAT_BODY  = new THREE.MeshStandardMaterial({ color:0x616779, metalness:.85, roughness:.32 });
    const MAT_JOINT = new THREE.MeshStandardMaterial({ color:0xaab3c2, metalness:1.0, roughness:.25 });
    const MAT_VISOR = new THREE.MeshStandardMaterial({ color:0x0f1623, emissive:0x44caff, emissiveIntensity:1.6, metalness:.9, roughness:.2 });

    const G_TORSO    = new THREE.BoxGeometry(.9,1.25,.55);
    const G_SHOULDER = new THREE.BoxGeometry(1.1,.2,.6);
    const G_HEAD     = new THREE.SphereGeometry(.38, 12, 10);
    const G_NECK     = new THREE.CylinderGeometry(.08,.08,.3, 8);
    const G_VISOR    = new THREE.BoxGeometry(.52,.18,.03);

    const G_JOINT    = new THREE.SphereGeometry(.14, 10, 8);
    const G_CAPS_UP  = new THREE.CapsuleGeometry(.11, .6, 4, 6);
    const G_CAPS_LO  = new THREE.CapsuleGeometry(.10, .5, 4, 6);
    // keine FÃ¼ÃŸe

    /* ======= Blink-Death Parameter ======= */
    const BLINK_COUNT    = 3;
    const BLINK_INTERVAL = 0.12;
    const SINK_SPEED     = 10.0;
    const RED_FLASH_MAT  = new THREE.MeshBasicMaterial({ color:0xff0000, toneMapped:false });

    /* ======= Runde, rote Beacon ======= */
    function makeDiscTexture(size=64){
      const c = document.createElement('canvas');
      c.width = c.height = size;
      const ctx = c.getContext('2d');
      const g = ctx.createRadialGradient(size/2,size/2,0, size/2,size/2,size/2);
      g.addColorStop(0.0, 'rgba(255,0,0,1)');
      g.addColorStop(0.5, 'rgba(255,0,0,0.85)');
      g.addColorStop(1.0, 'rgba(255,0,0,0)');
      ctx.fillStyle = g;
      ctx.fillRect(0,0,size,size);
      const tex = new THREE.CanvasTexture(c);
      tex.colorSpace = THREE.SRGBColorSpace;
      return tex;
    }
    const BEACON_TEX = makeDiscTexture();

    /* ======= Deterministisches 2D-Random ======= */
    function rand2(i,j){
      let h = (i*374761393) ^ (j*668265263);
      h = (h ^ (h>>>13)) * 1274126177;
      h = (h ^ (h>>>16)) >>> 0;
      return h / 4294967296;
    }

    /* ======= Init ======= */
    init();
    animate();

    function init(){
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x11203a);
      scene.fog = new THREE.FogExp2(0x0e1a32, 0.006);

      camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);

      renderer = new THREE.WebGLRenderer({
        antialias: !isMobile,
        powerPreference:'high-performance',
        alpha:false, stencil:false
      });
      renderer.setSize(innerWidth, innerHeight);
      renderer.setPixelRatio(Math.min(devicePixelRatio, MAX_RATIO));
      renderer.shadowMap.enabled = !isMobile;
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.38;
      document.body.appendChild(renderer.domElement);

      // Lighting
      const hemi = new THREE.HemisphereLight(0x5577cc, 0x220022, 1.8);
      scene.add(hemi);
      const sun = new THREE.DirectionalLight(0xffffff, 1.9);
      sun.position.set(12,22,14);
      sun.castShadow = !isMobile;
      if(!isMobile){ sun.shadow.mapSize.set(1024,1024); }
      scene.add(sun);

      // Player
      player = makeRobot();
      scene.add(player);

      // NPCs
      for(let i=0;i<NPC_COUNT;i++){
        const n = makeRobot();
        const s = 0.9 + Math.random()*1.8;
        n.scale.set(s,s,s);
        n.userData.hit = s*1.1;
        n.position.set((Math.random()-.5)*CHUNK_SIZE*3, 1.7, (Math.random()-.5)*CHUNK_SIZE*3);
        n.rotation.y = Math.random()*Math.PI*2;
        n.userData.speed = NPC_SPEED;
        n.userData.phase = Math.random()*Math.PI*2;

        const beaconMat = new THREE.SpriteMaterial({
          map: BEACON_TEX, transparent: true, opacity: 0.75,
          blending: THREE.AdditiveBlending, depthWrite: false, toneMapped: false
        });
        const beacon = new THREE.Sprite(beaconMat);
        beacon.position.set(0, 2*s, 0);
        const base = .5*s;
        beacon.scale.setScalar(base);
        n.add(beacon);
        n.userData.beacon = beacon;
        n.userData.beaconBase = base;

        scene.add(n); npcs.push(n);
      }
      applyNpcBudget();

      // Pointer-Events
      addEventListener('pointerdown', onPointerDown, {passive:false});
      addEventListener('pointermove', onPointerMove, {passive:false});
      addEventListener('pointerup', onPointerUp, {passive:false});
      addEventListener('pointercancel', onPointerUp, {passive:false});
      addEventListener('resize', onResize);
      onResize();
    }

    /* ======= Robot ======= */
    function makeRobot(){
      const m=(g,mat=MAT_BODY)=>{ const mesh=new THREE.Mesh(g,mat); mesh.castShadow=!isMobile; mesh.receiveShadow=!isMobile; return mesh; };
      const g=new THREE.Group();

      const torso=m(G_TORSO); g.add(torso);
      const shoulder=m(G_SHOULDER, MAT_BODY); shoulder.position.y=.7; torso.add(shoulder);

      const head=m(G_HEAD, MAT_BODY); head.position.y=1.05; torso.add(head);
      const neck=m(G_NECK, MAT_BODY); neck.position.set(0,.85,0); torso.add(neck);
      const visor=m(G_VISOR, MAT_VISOR); visor.position.set(0,1.05,.23); torso.add(visor);

      const limb=(side,y,upperLen=.6,lowerLen=.5)=>{
        const grp=new THREE.Group();
        const shoulderJoint=m(G_JOINT, MAT_JOINT); shoulderJoint.position.set(side*.55, y, 0); grp.add(shoulderJoint);
        const up=m(G_CAPS_UP, MAT_BODY); up.position.y=-upperLen/2-.02; shoulderJoint.add(up);
        const elbow=m(G_JOINT, MAT_JOINT); elbow.position.y=-upperLen-.05; up.add(elbow);
        const lo=m(G_CAPS_LO, MAT_BODY); lo.position.y=-(lowerLen/2+.02); elbow.add(lo);
        return{grp, up, lo};
      };

      const la=limb( 1,.45), ra=limb(-1,.45), ll=limb(.28,-.55,.65,.55), rl=limb(-.28,-.55,.65,.55);
      torso.add(la.grp,ra.grp,ll.grp,rl.grp);

      g.userData={ leftArm:la,rightArm:ra,leftLeg:ll,rightLeg:rl };
      g.position.y=1.7;
      return g;
    }

    /* ======= Input Helpers ======= */
    function isInLinksArea(target){ return target && target.closest && target.closest('#links'); }
    function onPointerDown(e){
      if(useSwipe && (e.pointerType === 'touch' || e.pointerType === 'pen')){
        if (isInLinksArea(e.target)) return;
        dragging = true; moved = false;
        startX = lastX = e.clientX; startY = e.clientY; startTime = performance.now();
        e.preventDefault();
      }else{ shoot(); }
    }
    function onPointerMove(e){
      if(useSwipe && (e.pointerType === 'touch' || e.pointerType === 'pen')){
        if(!dragging) return;
        const dx = e.clientX - lastX;
        lastX = e.clientX;
        if(Math.abs(e.clientX - startX) > 8 || Math.abs(e.clientY - startY) > 8) moved = true;
        rotTarget = Math.max(-ROT_CLAMP, Math.min(ROT_CLAMP, rotTarget - dx * TOUCH_SENS));
        e.preventDefault();
      }else{
        mouseX = e.clientX;
      }
    }
    function onPointerUp(e){
      if(useSwipe && (e.pointerType === 'touch' || e.pointerType === 'pen')){
        const dt = performance.now() - startTime;
        const dx = e.clientX - startX, dy = e.clientY - startY;
        const tap = !moved && (dx*dx + dy*dy) < (18*18) && dt < 260;
        if(tap && !isInLinksArea(e.target)) shoot();
        dragging = false;
        e.preventDefault();
      }
    }

    function onResize(){
      const a = innerWidth/innerHeight;
      if(a < .6){ camera.fov = 86;  camOffset.set(0, 6.5, 12); lookY = 3.4; }
      else if(a < .85){ camera.fov = 82; camOffset.set(0, 5.2, 10); lookY = 3.0; }
      else if(a < 1){ camera.fov = 78; camOffset.set(0, 4.2, 8.8); lookY = 2.6; }
      else { camera.fov = 74; camOffset.set(0, 3.2, 7.2); lookY = 2.2; }
      camera.aspect=a; camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    }

    /* ======= Laser ======= */
    function acquireBeam(){
      const grp = beamPool.pop() || (function(){
        const g = new THREE.Group();
        const core = new THREE.Mesh(LASER_CORE_GEOM, LASER_CORE_MAT.clone());
        const glow = new THREE.Mesh(LASER_GLOW_GEOM, LASER_GLOW_MAT.clone());
        core.name='core'; glow.name='glow';
        g.add(glow); g.add(core);
        return g;
      })();
      grp.scale.set(1, LASER_LEN_HALF, 1);
      grp.userData.traveled = 0;
      return grp;
    }
    function releaseBeam(b){ b.visible=false; scene.remove(b); beamPool.push(b); }

    function shoot(){
      if(beams.length>=MAX_BEAMS) return;
      const start = player.localToWorld(new THREE.Vector3(0,0.9,0));
      const dir = new THREE.Vector3(0,0,-1).applyQuaternion(player.quaternion);
      const right= new THREE.Vector3(1,0,0).applyQuaternion(player.quaternion).normalize();
      dir.applyAxisAngle(right, THREE.MathUtils.degToRad(LASER_TILT_DEG)).normalize();
      const beam = acquireBeam();
      beam.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), dir);
      beam.position.copy(start).add(TMP_V1.copy(dir).multiplyScalar(LASER_LEN_HALF));
      beam.userData.dir = dir.clone();
      beam.visible=true;
      scene.add(beam); beams.push(beam);
    }

    /* ======= City Chunks ======= */
    function makeGrid(cx,cz){
      const g = new THREE.GridHelper(CHUNK_SIZE*2, 20, 0x77ffff, 0x9933ff);
      g.position.set(cx*CHUNK_SIZE, -0.02, cz*CHUNK_SIZE);
      g.material.transparent = true; g.material.opacity = .72;
      g.material.depthWrite = false;      // schreibt NICHT in Z â†’ Ã¼bermalt nichts
      g.material.depthTest  = true;       // respektiert vorhandene Z (Roboter/Outlines)
      g.material.fog = true;
      g.renderOrder = -1000;              // extrem frÃ¼h im transparenten Sortierblock
      scene.add(g); gridChunks.set(key(cx,cz), g);
    }

    function makeCity(cx,cz){
      const group = new THREE.Group();
      group.position.set(cx*CHUNK_SIZE,0,cz*CHUNK_SIZE);

      const TILE=70, ROAD=16, SETBK=4, PLAZA_N=4;

      const minX = group.position.x - CHUNK_SIZE/2;
      const maxX = group.position.x + CHUNK_SIZE/2;
      const minZ = group.position.z - CHUNK_SIZE/2;
      const maxZ = group.position.z + CHUNK_SIZE/2;

      const i0 = Math.floor(minX / TILE) - 1;
      const i1 = Math.floor(maxX / TILE) + 1;
      const j0 = Math.floor(minZ / TILE) - 1;
      const j1 = Math.floor(maxZ / TILE) + 1;

      const builds = [];
      for(let i=i0; i<=i1; i++){
        for(let j=j0; j<=j1; j++){
          const cxw = (i + 0.5) * TILE;
          const czw = (j + 0.5) * TILE;
          const isPlaza = (i % PLAZA_N === 0) && (j % PLAZA_N === 0);
          const r = rand2(i, j);
          const occupied = !isPlaza && r > 0.25;
          if(!occupied) continue;

          const buildMax = TILE - ROAD - 2*SETBK;
          const w = Math.max(10, buildMax * (0.55 + 0.35 * rand2(i+11, j+3)));
          const d = Math.max(10, buildMax * (0.55 + 0.35 * rand2(i+7,  j+19)));
          const baseH = 26, varH=90, bias = ((i & 1) === 0 && (j & 1) === 0) ? 1.15 : 1.0;
          const h = baseH + varH * (0.35 + 0.65 * rand2(i+23, j+41)) * bias;

          const px = cxw - group.position.x + (rand2(i+5, j+9)-0.5) * (buildMax - w);
          const pz = czw - group.position.z + (rand2(i+13, j+27)-0.5) * (buildMax - d);

          if (px - w/2 < -CHUNK_SIZE/2-5 || px + w/2 > CHUNK_SIZE/2+5 ||
              pz - d/2 < -CHUNK_SIZE/2-5 || pz + d/2 > CHUNK_SIZE/2+5) continue;

          builds.push({w,d,h,px,pz});
        }
      }

      // GebÃ¤ude-KÃ¶rper: transparent, ohne Z-Schreiben
      const bodyMat = new THREE.MeshBasicMaterial({ color:0x0d0f22, transparent:true, opacity:.05 });
      bodyMat.depthWrite = false;
      bodyMat.polygonOffset = true;
      bodyMat.polygonOffsetFactor = 1;
      bodyMat.polygonOffsetUnits  = 1;

      const baseGeom = new THREE.BoxGeometry(1,1,1);
      const inst = new THREE.InstancedMesh(baseGeom, bodyMat, builds.length);
      inst.castShadow=false; inst.receiveShadow=false;
      inst.renderOrder = -2;
      const colorBuckets = new Map();
      for(const c of NEON) colorBuckets.set(c, []);

      const m = new THREE.Matrix4();
      const s = new THREE.Vector3();
      const q = new THREE.Quaternion();
      const p = new THREE.Vector3();

      for(let idx=0; idx<builds.length; idx++){
        const {w,d,h,px,pz} = builds[idx];
        p.set(px, h/2, pz); q.identity(); s.set(w, h, d);
        m.compose(p,q,s);
        inst.setMatrixAt(idx, m);

        const eg = new THREE.EdgesGeometry(new THREE.BoxGeometry(w,h,d));
        eg.applyMatrix4(new THREE.Matrix4().makeTranslation(px, h/2, pz));
        const rr = rand2(Math.floor(px + group.position.x), Math.floor(pz + group.position.z));
        const col = NEON[Math.floor(rr * NEON.length)];
        colorBuckets.get(col).push(eg);
      }
      inst.instanceMatrix.needsUpdate = true;
      group.add(inst);

      // Outlines: schreiben in die Tiefe â†’ Ã¼berlagern Grid zuverlÃ¤ssig
      for(const [col, list] of colorBuckets){
        if(!list.length) continue;
        const merged = mergeGeometries(list, false);
        const lnMat = new THREE.LineBasicMaterial({color:col});
        lnMat.depthWrite = true;        // <-- wichtig
        lnMat.depthTest  = true;
        lnMat.toneMapped = false;
        lnMat.fog = true;
        const ln = new THREE.LineSegments(merged, lnMat);
        ln.renderOrder = -100;          // beliebig unterhalb transparenter Effekte
        group.add(ln);
      }

      scene.add(group); cityChunks.set(key(cx,cz), group);
    }

    /* ======= Blink-Death ======= */
    function triggerBlinkDeath(npc, timeNow){
      if(npc.userData.dying) return;
      if(npc.userData.beacon){ npc.remove(npc.userData.beacon); npc.userData.beacon = null; }
      npc.userData.dying = { start: timeNow, sinking: false, _lastOn: undefined };
      npc.userData.speed = 0;

      const meshes = [], mats = [];
      npc.traverse(o=>{ if(o.isMesh){ meshes.push(o); mats.push(o.material); } });
      npc.userData.deathMeshes = meshes;
      npc.userData.deathOrigMats = mats;

      // Kill-Counter
      kills++; if(killsEl) killsEl.textContent = String(kills);
    }

    /* ======= Adaptive ======= */
    function autoResolution(dt){
      if (resCooldown > 0) { resCooldown--; return; }
      const ms = dt * 1000;
      msAvg = msAvg * 0.9 + ms * 0.1;
      const desired = 1000 / 60;
      const maxPR = Math.min(devicePixelRatio, MAX_RATIO);
      const curPR = renderer.getPixelRatio();
      if (msAvg > desired * 1.15 && curPR > 1){
        renderer.setPixelRatio(Math.max(1, curPR - 0.25));
        renderer.setSize(innerWidth, innerHeight, false);
        resCooldown = 30;
      } else if (msAvg < desired * 0.85 && curPR < maxPR){
        renderer.setPixelRatio(Math.min(maxPR, curPR + 0.25));
        renderer.setSize(innerWidth, innerHeight, false);
        resCooldown = 30;
      }
    }
    function applyNpcBudget(){ for (let i=0;i<npcs.length;i++) npcs[i].visible = (i < npcBudget); }
    function tuneNpcBudget(){
      if (msAvg > 22 && npcBudget > 18){ npcBudget -= 2; applyNpcBudget(); }
      if (msAvg < 14 && npcBudget < NPC_MAX){ npcBudget += 2; applyNpcBudget(); }
    }
    function disposeNode(node){
      node.traverse(obj=>{
        if (obj.geometry) obj.geometry.dispose();
        if (obj.material){
          if (Array.isArray(obj.material)) obj.material.forEach(m=>m.dispose());
          else obj.material.dispose();
        }
        if (obj.texture) obj.texture.dispose?.();
      });
    }

    /* ======= Main Loop ======= */
    function animate(){
      requestAnimationFrame(animate);
      const dt = Math.min(clock.getDelta(), 0.05);
      const t  = clock.getElapsedTime();

      autoResolution(dt);
      tuneNpcBudget();

      // Steuerung
      const rotFactor = -Math.PI * 3.2;
      if(!useSwipe){ rotTarget = ((mouseX - innerWidth/2) / (innerWidth/2)) * rotFactor; }
      player.rotation.y += (rotTarget - player.rotation.y) * 0.1;

      // Bewegung
      player.translateZ(-RUN_SPEED*dt);

      // Spieler-Animation
      const swing = Math.sin(t*6)*.5, bend = Math.max(0,Math.sin(t*6))*.5;
      const ud = player.userData;
      ud.leftLeg.up.rotation.x  = swing;
      ud.rightLeg.up.rotation.x = -swing;
      ud.leftLeg.lo.rotation.x  = -bend;
      ud.rightLeg.lo.rotation.x = -Math.max(0,Math.sin(t*6+Math.PI))*.5;
      ud.leftArm.up.rotation.x  = -swing*.6;
      ud.rightArm.up.rotation.x =  swing*.6;

      // NPCs
      for(let i=npcs.length-1;i>=0;i--){
        const n = npcs[i];
        if (!n.visible && !n.userData.dying) continue;

        if(n.userData.dying){
          const d = n.userData.dying;
          const phase = Math.floor((t - d.start)/BLINK_INTERVAL);
          if(!d.sinking){
            if(phase < BLINK_COUNT*2){
              const on = (phase % 2) === 0;
              if(on !== d._lastOn){
                d._lastOn = on;
                const meshes = n.userData.deathMeshes, mats = n.userData.deathOrigMats;
                for(let k=0;k<meshes.length;k++){ meshes[k].material = on ? RED_FLASH_MAT : mats[k]; }
              }
            }else{
              const meshes = n.userData.deathMeshes;
              for(let k=0;k<meshes.length;k++){ meshes[k].material = RED_FLASH_MAT; }
              d.sinking = true;
            }
          }else{
            n.position.y -= SINK_SPEED*dt;
            if(n.position.y < -2.5){ scene.remove(n); npcs.splice(i,1); continue; }
          }
        }else{
          n.translateZ(-n.userData.speed*dt);
          if(Math.random()<.01) n.rotation.y += (Math.random()-.5)*Math.PI/2;

          // optionale Geh-Animation bei guter Performance
          if (msAvg < 22){
            const ph = t*6 + n.userData.phase;
            const sw = Math.sin(ph)*.45;
            const bn = Math.max(0, Math.sin(ph))*.45;
            const udn = n.userData;
            udn.leftLeg.up.rotation.x  = sw;
            udn.rightLeg.up.rotation.x = -sw;
            udn.leftLeg.lo.rotation.x  = -bn;
            udn.rightLeg.lo.rotation.x = -Math.max(0, Math.sin(ph+Math.PI))*.45;
            udn.leftArm.up.rotation.x  = -sw*.6;
            udn.rightArm.up.rotation.x =  sw*.6;
          }

          if(n.userData.beacon){
            const pulse = Math.sin(t*3.6 + n.userData.phase);
            const scale = n.userData.beaconBase * (1 + 0.1*pulse);
            n.userData.beacon.scale.setScalar(scale);
            n.userData.beacon.material.opacity = 0.65 + 0.2*pulse;
          }

          if(n.position.distanceToSquared(player.position) > (CHUNK_SIZE*CHUNK_SIZE*9)){
            n.position.copy(player.position).add(new THREE.Vector3((Math.random()-.5)*CHUNK_SIZE, 0, (Math.random()-.5)*CHUNK_SIZE));
          }
        }
      }

      // Laser
      for(let i=beams.length-1;i>=0;i--){
        const b = beams[i];
        const mv = TMP_V1.copy(b.userData.dir).multiplyScalar(LASER_SPEED*dt);
        b.position.add(mv);
        b.userData.traveled += mv.length();

        for(let j=npcs.length-1;j>=0;j--){
          const npc=npcs[j];
          if(!npc.visible || npc.userData.dying) continue;
          if(npc.position.distanceTo(b.position) < npc.userData.hit){
            triggerBlinkDeath(npc, t);
            releaseBeam(b); beams.splice(i,1);
            break;
          }
        }
        if(b.userData.traveled>600){ releaseBeam(b); beams.splice(i,1); }
      }

      // FX
      for(let i=explosions.length-1;i>=0;i--){
        const s=explosions[i];
        s.scale.multiplyScalar(1+dt*6);
        s.material.opacity -= dt*2.5;
        if(s.material.opacity<=0){ scene.remove(s); explosions.splice(i,1); }
      }

      // World streaming
      const cx = Math.floor(player.position.x/CHUNK_SIZE);
      const cz = Math.floor(player.position.z/CHUNK_SIZE);
      active.clear();
      let built = 0, buildCap = 1;
      for(let dx=-ACTIVE_RADIUS; dx<=ACTIVE_RADIUS; dx++){
        for(let dz=-ACTIVE_RADIUS; dz<=ACTIVE_RADIUS; dz++){
          const K = key(cx+dx, cz+dz); active.add(K);
          if(!gridChunks.has(K) && built<buildCap){ makeGrid(cx+dx, cz+dz); built++; }
          if(!cityChunks.has(K) && built<buildCap){ makeCity(cx+dx, cz+dz); built++; }
        }
      }
      for(const [k,o] of gridChunks) if(!active.has(k)){ scene.remove(o); disposeNode(o); gridChunks.delete(k); }
      for(const [k,o] of cityChunks) if(!active.has(k)){ scene.remove(o); disposeNode(o); cityChunks.delete(k); }

      // Kamera
      const camPos = TMP_V2.copy(player.position).add(camOffset.clone().applyQuaternion(player.quaternion));
      camera.position.lerp(camPos, .1);
      camera.lookAt(player.position.x, player.position.y+lookY, player.position.z);

      renderer.render(scene, camera);
    }

  </script>
</body>
</html>
