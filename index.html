<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ðŸ¤– Homepage | Maxi Riegel</title>
  <style>
    body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Inter', sans-serif; }
    canvas { display: block; }
    #links {
      position: absolute;
      bottom: 10px;
      width: 100%;
      text-align: center;
      z-index: 100;
    }
    #links a {
      color: white;
      text-decoration: none;
      margin: 0 15px;
      font-size: clamp(1rem, 3vw, 1.5rem); 
      transition: color 0.3s ease;
    }
    #links a:hover {
      color: #00ffff;
    }
  </style>
  <script async src="https://ga.jspm.io/npm:es-module-shims@1.6.3/dist/es-module-shims.js"></script>
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
  </script>
</head>
<body>
  <div id="links">
    <a href="https://www.linkedin.com/in/maximilianluisriegel/" target="_blank">LinkedIn</a>
    <a href="https://github.com/maxiriegel" target="_blank">GitHub</a>
    <a href="mailto:maximilianluis.riegel@gmail.com">E-Mail</a>
  </div>

  <script type="module">
    import * as THREE from 'three';

    let scene, camera, renderer, robot;
    const clock = new THREE.Clock();
    let mouseX = window.innerWidth / 2;

    const CHUNK_SIZE = 200;
    const ROBOT_SPEED = 12.0;
    const ACTIVE_RADIUS = 2;

    let cameraOffset;

    const gridChunks = new Map();
    const buildingChunks = new Map();
    const activeChunkSet = new Set();

    function chunkKey(x, z) {
      return `${x},${z}`;
    }

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0a0a1a);
      scene.fog = new THREE.Fog(scene.background, 30, 120);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      cameraOffset = new THREE.Vector3(0, 3, 7);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);

      const hemisphereLight = new THREE.HemisphereLight(0x4a4a9a, 0xff00ff, 1.0);
      scene.add(hemisphereLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
      directionalLight.position.set(10, 20, 15);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      scene.add(directionalLight);

      robot = createRobot();
      scene.add(robot);

      window.addEventListener('resize', onWindowResize, false);
      window.addEventListener('mousemove', onInputMove, false);
      window.addEventListener('touchmove', onInputMove, { passive: false });

      onWindowResize();
      animate();
    }

    function createRobot() {
      const robotGroup = new THREE.Group();
      const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x555566, metalness: 0.9, roughness: 0.4 });
      const jointMaterial = new THREE.MeshStandardMaterial({ color: 0x9999aa, metalness: 1.0, roughness: 0.2 });
      const ledMaterial = new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x00ffff, emissiveIntensity: 2 });

      const createPart = (geometry, material = bodyMaterial) => {
        const mesh = new THREE.Mesh(geometry, material);
        mesh.castShadow = true;
        return mesh;
      };

      const torso = createPart(new THREE.BoxGeometry(0.8, 1.2, 0.5));
      torso.name = "torso";
      robotGroup.add(torso);

      const head = createPart(new THREE.SphereGeometry(0.4, 16, 12));
      head.position.y = 1.0;
      torso.add(head);

      const antennaBase = createPart(new THREE.CylinderGeometry(0.05, 0.05, 0.1), jointMaterial);
      antennaBase.position.y = 0.4;
      head.add(antennaBase);
      const antennaStick = createPart(new THREE.CylinderGeometry(0.02, 0.02, 0.5), bodyMaterial);
      antennaStick.position.y = 0.3;
      antennaBase.add(antennaStick);
      const antennaTip = createPart(new THREE.SphereGeometry(0.04), ledMaterial);
      antennaTip.position.y = 0.25;
      antennaStick.add(antennaTip);

      // Arme und Beine mit Gelenken
      const limb = (side, yOffset) => {
        const group = new THREE.Group();
        const shoulder = createPart(new THREE.SphereGeometry(0.15), jointMaterial);
        shoulder.position.set(side * 0.5, yOffset, 0);
        group.add(shoulder);

        const upper = createPart(new THREE.CylinderGeometry(0.1, 0.1, 0.7));
        upper.position.y = -0.35;
        shoulder.add(upper);

        const elbow = createPart(new THREE.SphereGeometry(0.12), jointMaterial);
        elbow.position.y = -0.35;
        upper.add(elbow);

        const lower = createPart(new THREE.CylinderGeometry(0.1, 0.1, 0.6));
        lower.position.y = -0.3;
        elbow.add(lower);

        return { group, shoulder, upper, elbow, lower };
      };

      // Arme
      const leftArm = limb(1, 0.4);
      const rightArm = limb(-1, 0.4);
      torso.add(leftArm.group);
      torso.add(rightArm.group);

      // Beine
      const leftLeg = limb(0.25, -0.75);
      const rightLeg = limb(-0.25, -0.75);
      torso.add(leftLeg.group);
      torso.add(rightLeg.group);

      robotGroup.userData = { leftArm, rightArm, leftLeg, rightLeg };
      robotGroup.position.y = 1.7;
      return robotGroup;
    }

    function generateGridChunk(chunkX, chunkZ) {
      const grid = new THREE.GridHelper(CHUNK_SIZE * 2, 20, 0x00ffff, 0x5500ff);
      grid.position.set(chunkX * CHUNK_SIZE, -0.01, chunkZ * CHUNK_SIZE);
      scene.add(grid);
      gridChunks.set(chunkKey(chunkX, chunkZ), grid);
    }

    function generateCityChunk(chunkX, chunkZ) {
      const chunkGroup = new THREE.Group();
      chunkGroup.position.set(chunkX * CHUNK_SIZE, 0, chunkZ * CHUNK_SIZE);

      const numBuildings = 70;
      const roadWidth = 20;
      const positions = [];

      const buildingFillMaterial = new THREE.MeshBasicMaterial({ color: 0x050510, transparent: true, opacity: 0.3 });
      const neonColors = [0x00ffff, 0xff00ff, 0x00ff00, 0xffff00, 0xff6600, 0xff0000];

      for (let i = 0; i < numBuildings; i++) {
        const width = 8 + Math.random() * 15;
        const depth = 8 + Math.random() * 15;
        const height = 20 + Math.random() * 80;

        let tries = 0, finalX, finalZ, posValid = false;
        while (!posValid && tries++ < 50) {
          const x = (Math.random() - 0.5) * (CHUNK_SIZE * 1.5 - roadWidth);
          const z = (Math.random() - 0.5) * CHUNK_SIZE;
          finalX = x > 0 ? x + roadWidth / 2 : x - roadWidth / 2;
          finalZ = z;
          const box = new THREE.Box3().setFromCenterAndSize(new THREE.Vector3(finalX, 0, finalZ), new THREE.Vector3(width, 1, depth));
          posValid = !positions.some(p => box.intersectsBox(p));
        }
        if (!posValid) continue;
        positions.push(new THREE.Box3().setFromCenterAndSize(new THREE.Vector3(finalX, 0, finalZ), new THREE.Vector3(width, 1, depth)));

        const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
        const buildingFill = new THREE.Mesh(buildingGeometry, buildingFillMaterial);
        const edges = new THREE.EdgesGeometry(buildingGeometry);
        const outline = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: neonColors[Math.floor(Math.random() * neonColors.length)] }));
        buildingFill.add(outline);
        buildingFill.position.set(finalX, height / 2, finalZ);
        chunkGroup.add(buildingFill);
      }
      scene.add(chunkGroup);
      buildingChunks.set(chunkKey(chunkX, chunkZ), chunkGroup);
    }

    function onInputMove(e) {
      e.preventDefault();
      mouseX = e.touches ? e.touches[0].clientX : e.clientX;
if (mouseX <= 5) mouseX = -Infinity;
else if (mouseX >= window.innerWidth - 5) mouseX = Infinity;
    }

    function onWindowResize() {
      const aspect = window.innerWidth / window.innerHeight;
      camera.aspect = aspect;
      camera.fov = aspect < 1 ? 90 : 75;
      cameraOffset.set(0, aspect < 1 ? 4 : 3, aspect < 1 ? 8 : 7);
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      const t = clock.getElapsedTime();

      let targetRotationY;
if (mouseX === Infinity) {
  targetRotationY = robot.rotation.y - 1000; // simulate strong turn left
} else if (mouseX === -Infinity) {
  targetRotationY = robot.rotation.y + 1000; // simulate strong turn right
} else {
  targetRotationY = ((mouseX - window.innerWidth / 2) / (window.innerWidth / 2)) * -Math.PI * 2;
}
      if (!isFinite(targetRotationY)) targetRotationY = 0;
robot.rotation.y += (targetRotationY - robot.rotation.y) * 0.1;
      robot.translateZ(-ROBOT_SPEED * delta);

      const swing = Math.sin(t * 6) * 0.5;
      const bend = Math.max(0, Math.sin(t * 6)) * 0.5;

      robot.userData.leftLeg.upper.rotation.x = swing;
      robot.userData.rightLeg.upper.rotation.x = -swing;
      robot.userData.leftLeg.lower.rotation.x = -bend;
      robot.userData.rightLeg.lower.rotation.x = -Math.max(0, Math.sin(t * 6 + Math.PI)) * 0.5;

      robot.userData.leftArm.upper.rotation.x = -swing * 0.6;
      robot.userData.rightArm.upper.rotation.x = swing * 0.6;

      const cx = Math.floor(robot.position.x / CHUNK_SIZE);
      const cz = Math.floor(robot.position.z / CHUNK_SIZE);
      activeChunkSet.clear();
      for (let dx = -ACTIVE_RADIUS; dx <= ACTIVE_RADIUS; dx++) {
        for (let dz = -ACTIVE_RADIUS; dz <= ACTIVE_RADIUS; dz++) {
          const key = chunkKey(cx + dx, cz + dz);
          activeChunkSet.add(key);
          if (!gridChunks.has(key)) generateGridChunk(cx + dx, cz + dz);
          if (!buildingChunks.has(key)) generateCityChunk(cx + dx, cz + dz);
        }
      }
      for (const [k, obj] of gridChunks) if (!activeChunkSet.has(k)) scene.remove(obj), gridChunks.delete(k);
      for (const [k, obj] of buildingChunks) if (!activeChunkSet.has(k)) scene.remove(obj), buildingChunks.delete(k);

      const camPos = robot.position.clone().add(cameraOffset.clone().applyQuaternion(robot.quaternion));
      camera.position.lerp(camPos, 0.1);
      const lookAt = robot.position.clone();
      lookAt.y += 2.0;
      camera.lookAt(lookAt);
      renderer.render(scene, camera);
    }

    init();
  </script>
</body>
</html>
